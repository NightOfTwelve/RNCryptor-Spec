# RNCryptor Data Format Specification Version 3.1

## Data Layout

### Key-based Encryption
    Byte:     |    0    |    1    | 2-17 | <-      ...     -> | n-32 - n |
    Contents: | version | options |  IV  | ... ciphertext ... |   HMAC   |
              |         | bit 0=0 |      |                    |          |

### Password-based Encryption
    Byte:     |    0    |    1    |      2-9       |  10-17   | 18-33 | <-      ...     -> | n-32 - n |
    Contents: | version | options | encryptionSalt | HMACSalt |  IV   | ... ciphertext ... |   HMAC   |
              |         | bit 0=1 |                |          |       |                    |          |

### Field definitions

* version (1 byte): Data format major version. Currently 3.
* options (1 byte): 
    * bit 0 - (boolean) uses password
    * bit 4-6 - (int) log10(pbkdf2_iterations). Bit 6 is MSB. 0 defaults to 10,000.
* encryptionSalt (8 bytes): iff option includes "uses password"
* HMACSalt (8 bytes): iff options includes "uses password"
* IV (16 bytes)
* ciphertext (variable) -- Encrypted in CBC mode
* HMAC (32 bytes)

All data is in network order (big-endian).

Note that the version of the RNCryptor ObjC library is not directly related to the version of the RNCryptor file format. For example, v2.2 of the RNCryptor ObjC library writes v3 of the file format. The versioning of an implementation is related to its API, not the file formats it supports.

## Implementation Procedure

Unless otherwise noted, all example implementations are given in an abtract, idealized language. It includes the following constructs:

* `||` - Operator that concatenates two octet strings.
* `RandomDataOfLength(n)` - Returns `n` random octets generated by a [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator).
* `PBKDF2(PRF algorithm, Password, Salt, iterations, output length)` - Returns the result of [PBKDF2 algorithm](https://tools.ietf.org/html/rfc2898).
* `AES(key length, mode, key, iv, plaintext)` - Returns the results of the AES algorithm using the block cipher mode `mode`.
* `HMAC(hash function, key, data)` - Returns the result of the [HMAC algorithm](https://tools.ietf.org/html/rfc2104).
* `Split()` - Returns a list of components as defined by the format.
* `ConsistentTimeEqual(x, y)` - Compares `x` and `y` in consistent time (without shortcuts).
* `Assert(condition)` - Indicates a programming error if condition is not met.
* `FAIL` - Token indicating a failure.
* `SHA1` - Token indicating SHA-1 hash function.
* `SHA256` - Token indicating SHA-2 hash function with 256-bit length.
* `CBCMode` - Token indicating [cipher block chaining (CBC)](https://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29) block cipher mode.

## Key-based encryption

```
def Encrypt(encryptionKey[32], hmacKey[32], plaintext) =
    iv = RandomDataOfLength(8 bytes)        
    header = 0x03 || 0x00 || iv
    ciphertext = AES(256 bits, CBCMode, encryptionKey, iv, plaintext)
    hmac = HMAC(SHA256, hmacKey, header || ciphertext)
    message = header || ciphertext || hmac
    return message
```

1. Generate a random IV.
2. Construct the header.
3. Encrypt the data using AES-256-CBC.
4. HMAC the header and ciphertext with SHA-256.
5. Put these elements together in the format given. 

## Key-based Decryption

```
def Decrypt(encryptionKey[32], hmacKey[32], message) =
    (version, options, iv, ciphertext, hmac) = Split(message)

    header = version || options || iv
    computedHmac = HMAC(header || ciphertext, hmacKey, SHA-256)
    if ! ConsistentTimeEqual(computedHmac, hmac) return FAIL
    else return AES256Decrypt(ciphertext, ModeCBC, iv, encryptionKey)
```

1. Pull apart the pieces as described in the data format.
2. Compute the expected HMAC from the header and ciphertext
3. Compare the expected HMAC to the provided HMAC. If there is a mismatch, return a failure.
4. If the HMACs match, then decrypt and return the plaintext.

## Password-based Encryption

```
def Encrypt(password, plaintext, log10Rounds) =
    Assert(password.length > 0)
    Assert(log10Rounds >= 0)
    Assert(log10Rounds <= 7)

    if (log10Rounds == 0) rounds = 10000
    else rounds = exp10(log10Rounds)

    encryptionSalt = RandomDataOfLength(8 bytes)
    encryptionKey = PBKDF2(SHA1, password, encryptionSalt, rounds, 256 bits)

    hmacSalt = RandomDataOfLength(8 bytes)
    hmacKey = PBKDF2(SHA1, password, hmacSalt, rounds, 256 bits)

    options = (1 << 0) | (log10Rounds << 4)

    iv = RandomDataOfLength(16 bytes)

    header = 0x03 || options || encryptionSalt || hmacSalt || iv
    ciphertext = AES(256 bits, CBCMode, encryptionKey, iv, plaintext)
    hmac = HMAC(SHA256, hmacKey, header || ciphertext)
    message = header || ciphertext || hmac
    return message
```

1. Password must be non-empty.
2. The number of rounds must be between 10 (0 means 10,000) and 1,000,000.
3. If log10Rounds is zero, set rounds to the default value of 10,000. Otherwise, set rounds to 10^log10Rounds.
4. Generate a random encryption salt.
5. Generate the encryption key using PBKDF2 and the given number of rounds.
6. Generate a random HMAC salt.
7. Generate the HMAC key using PBKDF2 and the given number of rounds.
8. Compute options with the first bit of 1, and log10Rounds in bits 4-6.
9. Generate a random IV.
10. Construct the header.
11. Encrypt the data using AES-256-CBC.
12. HMAC the header and ciphertext with SHA-256.
13. Put these elements together in the format given.

Note: RNCryptor uses SHA-1 for PBKDF2, but SHA-256 for HMAC.

## Password-based decryption (abstract language)

```
def Decrypt(password, message) =
    (version, options, encryptionSalt, hmacSalt, iv, ciphertext, hmac) = Split(message)

    rounds = (options & 0x70) >> 4
    if (rounds == 0) rounds = 10000
    else rounds = exp10(rounds)

    encryptionKey = PKBDF2(SHA1, password, hmacSalt, 10k iterations, 256 bites)
    hmacKey = PBKDF2(SHA1, password, hmacSalt, 10k iterations, 256 bits)

    header = version || options || encryptionSalt || hmacSalt || iv
    computedHmac = HMAC(header || ciphertext, hmacKey, SHA-256)
    if ! ConsistentTimeEqual(computedHmac, hmac) return FAIL
    else return AES256Decrypt(ciphertext, ModeCBC, iv, encryptionKey)
```

1. Pull apart the pieces as described in the data format.
2. Extract bits 4-6 from options. If zero, then rounds is 10,000. Otherwise, raise ten to that power and set as rounds.
3. Generate the encryption key using PBKDF2 and the given number of rounds.
4. Generate the HMAC key using PBKDF2 and the given number of rounds.
5. Compare the expected HMAC to the provided HMAC. If there is a mismatch, return a failure.
6. If the HMACs match, then decrypt and return the plaintext.

Note: The RNCryptor format v3 uses SHA-1 for PBKDF2, but SHA-256 for HMAC.

## Consistent-time equality checking

When comparing the computed HMAC with the expected HMAC, it is important that your comparison be made in consistent time. Your comparison function should compare all of the bytes of the ExpectedHMAC, even if it finds a mismatch. Otherwise, your comparison can be subject to a timing attack, where the attacker sends you different HMACs and times how long it takes you to return that they are not equal. Using this, the attacker can progressively determine each byte of the HMAC.

Here is an example consistent-time equality function in ObjC:
``` objc
- (BOOL)rnc_isEqualInConsistentTime:(NSData *)otherData {
  // The point of this routine is XOR the bytes of each data and accumulate the results with OR.
  // If any bytes are different, then the OR will accumulate some non-0 value.
  uint8_t result = otherData.length - self.length;  // Start with 0 (equal) only if our lengths are equal

  const uint8_t *myBytes = [self bytes];
  const NSUInteger myLength = [self length];
  const uint8_t *otherBytes = [otherData bytes];
  const NSUInteger otherLength = [otherData length];

  for (NSUInteger i = 0; i < otherLength; ++i) {
    // Use mod to wrap around ourselves if they are longer than we are.
    // Remember, we already broke equality if our lengths are different.
    result |= myBytes[i % myLength] ^ otherBytes[i];
  }

  return result == 0;
}
```

## Changes since version 3

* Version 3.1 adds `pbkdf2_iterations` to the options. It is backward compatible with v3.0.
* Clarifiations to the example code.
* Explanation of the "abstract language" used in the example code.